/*
This source file is part of the Swift.org open source project

Copyright 2015 - 2016 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See http://swift.org/LICENSE.txt for license information
See http://swift.org/CONTRIBUTORS.txt for Swift project authors
*/

import TSCBasic
import Build
import TSCUtility
import PackageGraph
import PackageModel

/// An enumeration of the errors that can be generated by the run tool.
private enum RunError: Swift.Error {
    /// The package manifest has no executable product.
    case noExecutableFound

    /// Could not find a specific executable in the package manifest.
    case executableNotFound(String)

    /// There are multiple executables and one must be chosen.
    case multipleExecutables([String])
}

extension RunError: CustomStringConvertible {
    var description: String {
        switch self {
        case .noExecutableFound:
            return "no executable product available"
        case .executableNotFound(let executable):
            return "no executable product named '\(executable)'"
        case .multipleExecutables(let executables):
            let joinedExecutables = executables.joined(separator: ", ")
            return "multiple executable products available: \(joinedExecutables)"
        }
    }
}

public class RunToolOptions: ToolOptions {
    /// Returns the mode in with the tool command should run.
    var mode: RunMode {
        // If we got version option, just print the version and exit.
        if shouldPrintVersion {
            return .version
        }
        if shouldLaunchREPL {
            return .repl
        }
        return .run
    }

    /// If the executable product should be built before running.
    var shouldBuild = true

    /// If the test should be built.
    var shouldBuildTests = false

    /// If should launch the Swift REPL.
    var shouldLaunchREPL = false

    /// The executable product to run.
    var executable: String?

    /// The arguments to pass to the executable.
    var arguments: [String] = []
}

public enum RunMode {
    case version
    case repl
    case run
}

/// swift-run tool namespace
public class SwiftRunTool: SwiftTool<RunToolOptions> {

   public convenience init(args: [String]) {
       self.init(
            toolName: "run",
            usage: "[options] [executable [arguments ...]]",
            overview: "Build and run an executable product",
            args: args,
            seeAlso: type(of: self).otherToolNames()
        )
    }

    override func runImpl() throws {
        switch options.mode {
        case .version:
            print(Versioning.currentVersion.completeDisplayString)

        case .repl:
            // Load a custom package graph which has a special product for REPL.
            let graphLoader = { try self.loadPackageGraph(createREPLProduct: self.options.shouldLaunchREPL) }
            let buildParameters = try self.buildParameters()

            // Construct the build operation.
            let buildOp = BuildOperation(
                buildParameters: buildParameters,
                useBuildManifestCaching: false,
                packageGraphLoader: graphLoader,
                diagnostics: diagnostics,
                stdoutStream: self.stdoutStream
            )

            // Save the instance so it can be cancelled from the int handler.
            self.buildSystemRef.buildSystem = buildOp

            // Perform build.
            try buildOp.build()

            // Execute the REPL.
            let arguments = buildOp.buildPlan!.createREPLArguments()
            print("Launching Swift REPL with arguments: \(arguments.joined(separator: " "))")
            try run(getToolchain().swiftInterpreter, arguments: arguments)

        case .run:
            // Detect deprecated uses of swift run to interpret scripts.
            if let executable = options.executable, isValidSwiftFilePath(executable) {
                diagnostics.emit(.runFileDeprecation)
                // Redirect execution to the toolchain's swift executable.
                let swiftInterpreterPath = try getToolchain().swiftInterpreter
                // Prepend the script to interpret to the arguments.
                let arguments = [executable] + options.arguments
                try run(swiftInterpreterPath, arguments: arguments)
                return
            }

            // Redirect stdout to stderr because swift-run clients usually want
            // to ignore swiftpm's output and only care about the tool's output.
            self.redirectStdoutToStderr()

            if options.shouldBuildTests && !options.shouldBuild {
                diagnostics.emit(.mutuallyExclusiveArgumentsError(arguments:
                    [buildTestsOptionName, skipBuildOptionName]))
                return
            }

            let buildSystem = try createBuildSystem()
            let productName = try findProductName(in: buildSystem.getPackageGraph())

            if options.shouldBuildTests {
                try buildSystem.build(subset: .allIncludingTests)
            } else if options.shouldBuild {
                try buildSystem.build(subset: .product(productName))
            }

            let executablePath = try self.buildParameters().buildPath.appending(component: productName)
            try run(executablePath, arguments: options.arguments)
        }
    }

    /// Returns the path to the correct executable based on options.
    private func findProductName(in graph: PackageGraph) throws -> String {
        if let executable = options.executable {
            let executableExists = graph.allProducts.contains { $0.type == .executable && $0.name == executable }
            guard executableExists else {
                throw RunError.executableNotFound(executable)
            }
            return executable
        }

        // If the executable is implicit, search through root products.
        let rootExecutables = graph.rootPackages
            .flatMap { $0.products }
            .filter { $0.type == .executable }
            .map { $0.name }

        // Error out if the package contains no executables.
        guard rootExecutables.count > 0 else {
            throw RunError.noExecutableFound
        }

        // Only implicitly deduce the executable if it is the only one.
        guard rootExecutables.count == 1 else {
            throw RunError.multipleExecutables(rootExecutables)
        }

        return rootExecutables[0]
    }

    /// Executes the executable at the specified path.
    private func run(_ excutablePath: AbsolutePath, arguments: [String]) throws {
        // Make sure we are running from the original working directory.
        let cwd: AbsolutePath? = localFileSystem.currentWorkingDirectory
        if cwd == nil || originalWorkingDirectory != cwd {
            try ProcessEnv.chdir(originalWorkingDirectory)
        }

        let pathRelativeToWorkingDirectory = excutablePath.relative(to: originalWorkingDirectory)
        try exec(path: excutablePath.pathString, args: [pathRelativeToWorkingDirectory.pathString] + arguments)
    }

    /// Determines if a path points to a valid swift file.
    private func isValidSwiftFilePath(_ path: String) -> Bool {
        guard path.hasSuffix(".swift") else { return false }
        //FIXME: Return false when the path is not a valid path string.
        let absolutePath: AbsolutePath
        if path.first == "/" {
            absolutePath = AbsolutePath(path)
        } else {
            guard let cwd = localFileSystem.currentWorkingDirectory else {
                return false
            }
            absolutePath = AbsolutePath(cwd, path)
        }
        return localFileSystem.isFile(absolutePath)
    }

    override class func defineArguments(parser: ArgumentParser, binder: ArgumentBinder<RunToolOptions>) {
        binder.bind(
            option: parser.add(option: skipBuildOptionName, kind: Bool.self,
                usage: "Skip building the executable product"),
            to: { $0.shouldBuild = !$1 })

        binder.bind(
            option: parser.add(option: buildTestsOptionName, kind: Bool.self,
                               usage: "Build both source and test targets"),
            to: { $0.shouldBuildTests = $1 })

        binder.bindArray(
            positional: parser.add(
                positional: "executable", kind: [String].self, optional: true, strategy: .remaining,
                usage: "The executable to run", completion: .function("_swift_executable")),
            to: {
                $0.executable = $1.first!
                $0.arguments = Array($1.dropFirst())
            })

        binder.bind(
            option: parser.add(option: "--repl", kind: Bool.self,
                usage: "Launch Swift REPL for the package"),
            to: { $0.shouldLaunchREPL = $1 })
    }
}

fileprivate let buildTestsOptionName = "--build-tests"
fileprivate let skipBuildOptionName = "--skip-build"

extension SwiftRunTool: ToolName {
    static var toolName: String {
        return "swift run"
    }
}

private extension Diagnostic.Message {
    static var runFileDeprecation: Diagnostic.Message {
        .warning("'swift run file.swift' command to interpret swift files is deprecated; use 'swift file.swift' instead")
    }
}
